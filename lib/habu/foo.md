進捗.md

こういう感じのが動くようになった、とりあえずConstructor Injectionだけ。

```ruby
```

`@Inject` みたいなアノテーションをRubyで取る方法がわかったのが収穫です。

- `RubyVM::InstructionSequence.load_iseq` を `Module#prepend` でフックする
- `RubyVM::AbstractSyntaxTree.parse_file` でASTをパースし `@Inject` のアノテーションが何に掛かっているかを解析し、グローバル変数的なところにためておく

まあみなさん `TracePoint` でline eventとればいいじゃないの?と思うかもしれないんですが、単に `@Inject` と置いただけでは発火しません。
つぎに考えるのはISeq取り出して `@Inject` へのアクセスをみつければいいんじゃないの?ですが最適化でISeqからは情報が消えてそうです。
なのでASTの段階でしか単に `@Inject` と書いてある情報はとれない。

そうなるとメソッド定義のタイミングで `File.read` して前の行を見ればいいんじゃないの?と思うかもしれない。
でも自前パースになってしまうのであんまりよくなさそうだし同一行に `@Inject` かかれると動かなかったりする。
今回の場合はそういうコードには対応してない、でサポートしなくい手もある。
ただし、アノテーションを複雑に書いたり、アノテーションをいくつも書きたいときはASTベースの方がよいのでは、といった感想。

話を戻して、上記の方法でで依存性を注入するコンストラクタのリストができます。
あとは `#to_refinements` が呼ばれた段階で `#new` を引数なしで定義して `Container#new` に移譲するよう上書きしていけばよいだけです。

まだ試していないのですが同じ手法でPythonのデコレータが実装できそうです。
デコレータ実装する場合はソース書き換えてからISeq.compileになるかもしれないけど。
